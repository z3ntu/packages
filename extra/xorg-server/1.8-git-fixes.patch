diff --git a/Xext/sync.c b/Xext/sync.c
index ce65314..2015fc1 100644
--- a/Xext/sync.c
+++ b/Xext/sync.c
@@ -94,7 +94,7 @@ static SyncCounter **SysCounterList = NULL;
 #define XSyncCAAllTrigger \
     (XSyncCACounter | XSyncCAValueType | XSyncCAValue | XSyncCATestType)
 
-static void SyncComputeBracketValues(SyncCounter *, Bool);
+static void SyncComputeBracketValues(SyncCounter *);
 
 static void SyncInitServerTime(void);
 
@@ -167,7 +167,7 @@ SyncDeleteTriggerFromCounter(SyncTrigger *pTrigger)
     }
 
     if (IsSystemCounter(pTrigger->pCounter))
-	SyncComputeBracketValues(pTrigger->pCounter, /*startOver*/ TRUE);
+	SyncComputeBracketValues(pTrigger->pCounter);
 }
 
 
@@ -194,7 +194,7 @@ SyncAddTriggerToCounter(SyncTrigger *pTrigger)
     pTrigger->pCounter->pTriglist = pCur;
 
     if (IsSystemCounter(pTrigger->pCounter))
-	SyncComputeBracketValues(pTrigger->pCounter, /*startOver*/ TRUE);
+	SyncComputeBracketValues(pTrigger->pCounter);
 
     return Success;
 }
@@ -351,7 +351,7 @@ SyncInitTrigger(ClientPtr client, SyncTrigger *pTrigger, XSyncCounter counter,
     }
     else if (IsSystemCounter(pCounter))
     {
-	SyncComputeBracketValues(pCounter, /*startOver*/ TRUE);
+	SyncComputeBracketValues(pCounter);
     }
 
     return Success;
@@ -646,7 +646,7 @@ SyncChangeCounter(SyncCounter *pCounter, CARD64 newval)
 
     if (IsSystemCounter(pCounter))
     {
-	SyncComputeBracketValues(pCounter, /* startOver */ FALSE);
+	SyncComputeBracketValues(pCounter);
     }
 }
 
@@ -913,7 +913,7 @@ SyncDestroySystemCounter(pointer pSysCounter)
 }
 
 static void
-SyncComputeBracketValues(SyncCounter *pCounter, Bool startOver)
+SyncComputeBracketValues(SyncCounter *pCounter)
 {
     SyncTriggerList *pCur;
     SyncTrigger *pTrigger;
@@ -930,11 +930,8 @@ SyncComputeBracketValues(SyncCounter *pCounter, Bool startOver)
     if (ct == XSyncCounterNeverChanges)
 	return;
 
-    if (startOver)
-    {
-	XSyncMaxValue(&psci->bracket_greater);
-	XSyncMinValue(&psci->bracket_less);
-    }
+    XSyncMaxValue(&psci->bracket_greater);
+    XSyncMinValue(&psci->bracket_less);
 
     for (pCur = pCounter->pTriglist; pCur; pCur = pCur->next)
     {
diff --git a/Xi/extinit.c b/Xi/extinit.c
index b7910cd..37f9856 100644
--- a/Xi/extinit.c
+++ b/Xi/extinit.c
@@ -1122,6 +1122,7 @@ RestoreExtensionEvents(void)
 static void
 IResetProc(ExtensionEntry * unused)
 {
+    XIResetProperties();
 
     ReplySwapVector[IReqCode] = ReplyNotSwappd;
     EventSwapVector[DeviceValuator] = NotImplemented;
diff --git a/Xi/xiproperty.c b/Xi/xiproperty.c
index be07831..8b80637 100644
--- a/Xi/xiproperty.c
+++ b/Xi/xiproperty.c
@@ -403,6 +403,15 @@ XIGetKnownProperty(char *name)
     return 0;
 }
 
+void
+XIResetProperties(void)
+{
+    int i;
+
+    for (i = 0; i < (sizeof(dev_properties)/sizeof(struct dev_properties)); i++)
+        dev_properties[i].type = None;
+}
+
 /**
  * Convert the given property's value(s) into @nelem_return integer values and
  * store them in @buf_return. If @nelem_return is larger than the number of
diff --git a/Xi/xiproperty.h b/Xi/xiproperty.h
index 69b41fa..d8b8863 100644
--- a/Xi/xiproperty.h
+++ b/Xi/xiproperty.h
@@ -62,4 +62,7 @@ void SRepXIListProperties(ClientPtr client, int size,
                           xXIListPropertiesReply *rep);
 void SRepXIGetProperty(ClientPtr client, int size,
                        xXIGetPropertyReply *rep);
+
+void XIResetProperties(void);
+
 #endif /* XIPROPERTY_H */
diff --git a/dix/devices.c b/dix/devices.c
index 6119dce..b55df16 100644
--- a/dix/devices.c
+++ b/dix/devices.c
@@ -318,10 +318,6 @@ EnableDevice(DeviceIntPtr dev, BOOL sendevent)
         }
     }
 
-    /* Before actually enabling the device, we need to make sure the event
-     * list's events have enough memory for a ClassesChangedEvent from the
-     * device
-     */
     if ((*prev != dev) || !dev->inited ||
 	((ret = (*dev->deviceProc)(dev, DEVICE_ON)) != Success)) {
         ErrorF("[dix] couldn't enable device %d\n", dev->id);
@@ -474,7 +470,8 @@ ActivateDevice(DeviceIntPtr dev, BOOL sendevent)
 
     /* Initialize memory for sprites. */
     if (IsMaster(dev) && dev->spriteInfo->spriteOwner)
-        pScreen->DeviceCursorInitialize(dev, pScreen);
+        if (!pScreen->DeviceCursorInitialize(dev, pScreen))
+            ret = BadAlloc;
 
     SendDevicePresenceEvent(dev->id, DeviceAdded);
     if (sendevent)
@@ -857,6 +854,8 @@ CloseDevice(DeviceIntPtr dev)
     }
 
     if (DevHasCursor(dev) && dev->spriteInfo->sprite) {
+	if (dev->spriteInfo->sprite->current)
+	    FreeCursor(dev->spriteInfo->sprite->current, None);
         xfree(dev->spriteInfo->sprite->spriteTrace);
         xfree(dev->spriteInfo->sprite);
     }
diff --git a/dix/events.c b/dix/events.c
index 6d0137d..5de1505 100644
--- a/dix/events.c
+++ b/dix/events.c
@@ -2943,6 +2943,7 @@ InitializeSprite(DeviceIntPtr pDev, WindowPtr pWin)
 {
     SpritePtr pSprite;
     ScreenPtr pScreen;
+    CursorPtr pCursor;
 
     if (!pDev->spriteInfo->sprite)
     {
@@ -2986,8 +2987,7 @@ InitializeSprite(DeviceIntPtr pDev, WindowPtr pWin)
 
     if (pWin)
     {
-        pSprite->current = wCursor(pWin);
-        pSprite->current->refcnt++;
+	pCursor = wCursor(pWin);
 	pSprite->spriteTrace = (WindowPtr *)xcalloc(1, 32*sizeof(WindowPtr));
 	if (!pSprite->spriteTrace)
 	    FatalError("Failed to allocate spriteTrace");
@@ -3000,13 +3000,18 @@ InitializeSprite(DeviceIntPtr pDev, WindowPtr pWin)
 	pSprite->pDequeueScreen = pSprite->pEnqueueScreen;
 
     } else {
-        pSprite->current = NullCursor;
+        pCursor = NullCursor;
 	pSprite->spriteTrace = NULL;
 	pSprite->spriteTraceSize = 0;
 	pSprite->spriteTraceGood = 0;
 	pSprite->pEnqueueScreen = screenInfo.screens[0];
 	pSprite->pDequeueScreen = pSprite->pEnqueueScreen;
     }
+    if (pCursor)
+	pCursor->refcnt++;
+    if (pSprite->current)
+	FreeCursor(pSprite->current, None);
+    pSprite->current = pCursor;
 
     if (pScreen)
     {
@@ -3059,6 +3064,7 @@ UpdateSpriteForScreen(DeviceIntPtr pDev, ScreenPtr pScreen)
 {
     SpritePtr pSprite = NULL;
     WindowPtr win = NULL;
+    CursorPtr pCursor;
     if (!pScreen)
         return ;
 
@@ -3074,8 +3080,12 @@ UpdateSpriteForScreen(DeviceIntPtr pDev, ScreenPtr pScreen)
     pSprite->hotLimits.x2 = pScreen->width;
     pSprite->hotLimits.y2 = pScreen->height;
     pSprite->win = win;
-    pSprite->current = wCursor (win);
-    pSprite->current->refcnt++;
+    pCursor = wCursor(win);
+    if (pCursor)
+	pCursor->refcnt++;
+    if (pSprite->current)
+	FreeCursor(pSprite->current, 0);
+    pSprite->current = pCursor;
     pSprite->spriteTraceGood = 1;
     pSprite->spriteTrace[0] = win;
     (*pScreen->CursorLimits) (pDev,
diff --git a/doc/Xserver.man.pre b/doc/Xserver.man.pre
index 8144c8a..ce3b3a1 100644
--- a/doc/Xserver.man.pre
+++ b/doc/Xserver.man.pre
@@ -100,12 +100,12 @@ specifies a file which contains a collection of authorization records used
 to authenticate access.  See also the \fIxdm\fP(1) and 
 \fIXsecurity\fP(__miscmansuffix__) manual pages.
 .TP 8
-.B \-bs
-disables backing store support on all screens.
-.TP 8
 .B \-br
 sets the default root window to solid black instead of the standard root weave
-pattern.
+pattern.   This is the default unless -retro or -wr is specified.
+.TP 8
+.B \-bs
+disables backing store support on all screens.
 .TP 8
 .B \-c
 turns off key-click.
@@ -117,17 +117,6 @@ sets key-click volume (allowable range: 0-100).
 sets the visual class for the root window of color screens.
 The class numbers are as specified in the X protocol.
 Not obeyed by all servers.
-.ig
-.TP 8
-.B \-config \fIfilename\fP
-reads more options from the given file.  Options in the file may be separated
-by newlines if desired.  If a '#' character appears on a line, all characters
-between it and the next newline are ignored, providing a simple commenting
-facility.  The \fB\-config\fP option itself may appear in the file.
-.BR NOTE :
-This option is disabled when the Xserver is run with an effective uid
-different from the user's real uid.
-..
 .TP 8
 .B \-core
 causes the server to generate a core dump on fatal errors.
@@ -184,6 +173,9 @@ sets the maximum big request to
 .I size
 MB.
 .TP 8
+.B \-nocursor
+disable the display of the pointer cursor.
+.TP 8
 .B \-nolisten \fItrans-type\fP
 disables a transport type.  For example, TCP/IP connections can be disabled
 with
@@ -584,11 +576,11 @@ Security: \fIXsecurity\fP(__miscmansuffix__), \fIxauth\fP(1), \fIXau\fP(1),
 Starting the server: \fIstartx\fP(1), \fIxdm\fP(1), \fIxinit\fP(1)
 .PP
 Controlling the server once started: \fIxset\fP(1), \fIxsetroot\fP(1),
-\fIxhost\fP(1)
+\fIxhost\fP(1), \fIxinput\fP(1), \fIxrandr\fP(1)
 .PP
 Server-specific man pages:
 \fIXorg\fP(1), \fIXdmx\fP(1), \fIXephyr\fP(1), \fIXnest\fP(1),
-\fIXvfb\fP(1), \fIXDarwin\fP(1), \fIXWin\fP(1).
+\fIXvfb\fP(1), \fIXquartz\fP(1), \fIXWin\fP(1).
 .PP
 Server internal documentation:
 .I "Definition of the Porting Layer for the X v11 Sample Server"
diff --git a/glx/glxdri2.c b/glx/glxdri2.c
index edd29b0..e791bf6 100644
--- a/glx/glxdri2.c
+++ b/glx/glxdri2.c
@@ -616,6 +616,7 @@ glxDRILeaveVT (int index, int flags)
 static void
 initializeExtensions(__GLXDRIscreen *screen)
 {
+    ScreenPtr pScreen = screen->base.pScreen;
     const __DRIextension **extensions;
     int i;
 
@@ -625,10 +626,17 @@ initializeExtensions(__GLXDRIscreen *screen)
 			 "GLX_MESA_copy_sub_buffer");
     LogMessage(X_INFO, "AIGLX: enabled GLX_MESA_copy_sub_buffer\n");
 
-    /* FIXME: only if DDX supports it */
     __glXEnableExtension(screen->glx_enable_bits, "GLX_INTEL_swap_event");
     LogMessage(X_INFO, "AIGLX: enabled GLX_INTEL_swap_event\n");
 
+    if (DRI2HasSwapControl(pScreen)) {
+	__glXEnableExtension(screen->glx_enable_bits,
+			     "GLX_SGI_swap_control");
+	__glXEnableExtension(screen->glx_enable_bits,
+			     "GLX_MESA_swap_control");
+	LogMessage(X_INFO, "AIGLX: enabled GLX_SGI_swap_control and GLX_MESA_swap_control\n");
+    }
+
     for (i = 0; extensions[i]; i++) {
 #ifdef __DRI_READ_DRAWABLE
 	if (strcmp(extensions[i]->name, __DRI_READ_DRAWABLE) == 0) {
@@ -639,19 +647,6 @@ initializeExtensions(__GLXDRIscreen *screen)
 	}
 #endif
 
-#ifdef __DRI_SWAP_CONTROL
-	if (strcmp(extensions[i]->name, __DRI_SWAP_CONTROL) == 0) {
-	    screen->swapControl =
-		(const __DRIswapControlExtension *) extensions[i];
-	    __glXEnableExtension(screen->glx_enable_bits,
-				 "GLX_SGI_swap_control");
-	    __glXEnableExtension(screen->glx_enable_bits,
-				 "GLX_MESA_swap_control");
-	    
-	    LogMessage(X_INFO, "AIGLX: enabled GLX_SGI_swap_control and GLX_MESA_swap_control\n");
-	}
-#endif
-
 #ifdef __DRI_TEX_BUFFER
 	if (strcmp(extensions[i]->name, __DRI_TEX_BUFFER) == 0) {
 	    screen->texBuffer =
diff --git a/hw/dmx/dmxextension.c b/hw/dmx/dmxextension.c
index 2266041..1a52e80 100644
--- a/hw/dmx/dmxextension.c
+++ b/hw/dmx/dmxextension.c
@@ -1160,7 +1160,7 @@ static void dmxBERestoreRenderGlyph(pointer value, XID id, pointer n)
 		     len_images);
 
     /* Clean up */
-    free(len_images);
+    free(images);
     free(gids);
     free(glyphs);    
 }
diff --git a/hw/xfree86/common/xf86DGA.c b/hw/xfree86/common/xf86DGA.c
index 804fd37..5d8addb 100644
--- a/hw/xfree86/common/xf86DGA.c
+++ b/hw/xfree86/common/xf86DGA.c
@@ -1088,13 +1088,15 @@ DGAProcessPointerEvent (ScreenPtr pScreen, DGAEvent *event, DeviceIntPtr mouse)
     ButtonClassPtr  butc = mouse->button;
     DGAScreenPtr    pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);
     DeviceEvent     ev;
+    DeviceIntPtr    master = GetMaster(mouse, MASTER_KEYBOARD);
 
     memset(&ev, 0, sizeof(ev));
     ev.header = ET_Internal;
     ev.length = sizeof(ev);
     ev.type = event->subtype;
     ev.corestate  = butc->state;
-    ev.corestate |= XkbStateFieldFromRec(&GetPairedDevice(mouse)->key->xkbInfo->state);
+    if (master && master->key)
+        ev.corestate |= XkbStateFieldFromRec(&master->key->xkbInfo->state);
 
     UpdateDeviceState(mouse, &ev);
 
diff --git a/hw/xfree86/common/xf86Xinput.c b/hw/xfree86/common/xf86Xinput.c
index a1a5527..bfa8dc0 100644
--- a/hw/xfree86/common/xf86Xinput.c
+++ b/hw/xfree86/common/xf86Xinput.c
@@ -551,9 +551,9 @@ InputClassMatches(XF86ConfInputClassPtr iclass, InputAttributes *attrs)
             return FALSE;
 
         for (cur = iclass->match_tag, match = FALSE; *cur && !match; cur++) {
-            const char *tag;
-            for(tag = *attrs->tags; *tag; tag++) {
-                if (!strcmp(tag, *cur)) {
+            char * const *tag;
+            for(tag = attrs->tags; *tag; tag++) {
+                if (!strcmp(*tag, *cur)) {
                     match = TRUE;
                     break;
                 }
diff --git a/hw/xfree86/doc/Makefile.am b/hw/xfree86/doc/Makefile.am
index 5809fa0..72bc5d9 100644
--- a/hw/xfree86/doc/Makefile.am
+++ b/hw/xfree86/doc/Makefile.am
@@ -6,4 +6,5 @@ endif
 
 EXTRA_DIST = \
 	README.DRI \
+	README.modes \
 	README.rapidaccess
diff --git a/hw/xfree86/dri2/dri2.c b/hw/xfree86/dri2/dri2.c
index 48618e1..2bdb733 100644
--- a/hw/xfree86/dri2/dri2.c
+++ b/hw/xfree86/dri2/dri2.c
@@ -45,6 +45,9 @@
 
 #include "xf86.h"
 
+CARD8 dri2_major; /* version of DRI2 supported by DDX */
+CARD8 dri2_minor;
+
 static int dri2ScreenPrivateKeyIndex;
 static DevPrivateKey dri2ScreenPrivateKey = &dri2ScreenPrivateKeyIndex;
 static int dri2WindowPrivateKeyIndex;
@@ -60,10 +63,13 @@ typedef struct _DRI2Drawable {
     int			 bufferCount;
     unsigned int	 swapsPending;
     ClientPtr		 blockedClient;
+    Bool		 blockedOnMsc;
     int			 swap_interval;
     CARD64		 swap_count;
-    CARD64		 target_sbc; /* -1 means no SBC wait outstanding */
+    int64_t		 target_sbc; /* -1 means no SBC wait outstanding */
     CARD64		 last_swap_target; /* most recently queued swap target */
+    CARD64		 last_swap_msc; /* msc at completion of most recent swap */
+    CARD64		 last_swap_ust; /* ust at completion of most recent swap */
     int			 swap_limit; /* for N-buffering */
 } DRI2DrawableRec, *DRI2DrawablePtr;
 
@@ -116,9 +122,11 @@ DRI2GetDrawable(DrawablePtr pDraw)
 int
 DRI2CreateDrawable(DrawablePtr pDraw)
 {
+    DRI2ScreenPtr   ds = DRI2GetScreen(pDraw->pScreen);
     WindowPtr	    pWin;
     PixmapPtr	    pPixmap;
     DRI2DrawablePtr pPriv;
+    CARD64          ust;
 
     pPriv = DRI2GetDrawable(pDraw);
     if (pPriv != NULL)
@@ -138,11 +146,17 @@ DRI2CreateDrawable(DrawablePtr pDraw)
     pPriv->bufferCount = 0;
     pPriv->swapsPending = 0;
     pPriv->blockedClient = NULL;
+    pPriv->blockedOnMsc = FALSE;
     pPriv->swap_count = 0;
     pPriv->target_sbc = -1;
     pPriv->swap_interval = 1;
-    pPriv->last_swap_target = -1;
+    /* Initialize last swap target from DDX if possible */
+    if (!ds->GetMSC || !(*ds->GetMSC)(pDraw, &ust, &pPriv->last_swap_target))
+	pPriv->last_swap_target = 0;
+
     pPriv->swap_limit = 1; /* default to double buffering */
+    pPriv->last_swap_msc = 0;
+    pPriv->last_swap_ust = 0;
 
     if (pDraw->type == DRAWABLE_WINDOW)
     {
@@ -390,6 +404,15 @@ DRI2ThrottleClient(ClientPtr client, DrawablePtr pDraw)
     return FALSE;
 }
 
+static void
+__DRI2BlockClient(ClientPtr client, DRI2DrawablePtr pPriv)
+{
+    if (pPriv->blockedClient == NULL) {
+	IgnoreClient(client);
+	pPriv->blockedClient = client;
+    }
+}
+
 void
 DRI2BlockClient(ClientPtr client, DrawablePtr pDraw)
 {
@@ -399,10 +422,8 @@ DRI2BlockClient(ClientPtr client, DrawablePtr pDraw)
     if (pPriv == NULL)
 	return;
 
-    if (pPriv->blockedClient == NULL) {
-	IgnoreClient(client);
-	pPriv->blockedClient = client;
-    }
+    __DRI2BlockClient(client, pPriv);
+    pPriv->blockedOnMsc = TRUE;
 }
 
 int
@@ -483,6 +504,11 @@ DRI2WaitMSCComplete(ClientPtr client, DrawablePtr pDraw, int frame,
 	AttendClient(pPriv->blockedClient);
 
     pPriv->blockedClient = NULL;
+    pPriv->blockedOnMsc = FALSE;
+
+    /* If there's still a swap pending, let DRI2SwapComplete free it */
+    if (pPriv->refCount == 0 && pPriv->swapsPending == 0)
+	DRI2FreeDrawable(pDraw);
 }
 
 static void
@@ -500,21 +526,26 @@ DRI2WakeClient(ClientPtr client, DrawablePtr pDraw, int frame,
     }
 
     /*
-     * Swap completed.  Either wake up an SBC waiter or a client that was
-     * blocked due to GLX activity during a swap.
+     * Swap completed.
+     * Wake the client iff:
+     *   - it was waiting on SBC
+     *   - was blocked due to GLX make current
+     *   - was blocked due to swap throttling
+     *   - is not blocked due to an MSC wait
      */
     if (pPriv->target_sbc != -1 &&
-	pPriv->target_sbc >= pPriv->swap_count) {
+	pPriv->target_sbc <= pPriv->swap_count) {
 	ProcDRI2WaitMSCReply(client, ((CARD64)tv_sec * 1000000) + tv_usec,
 			     frame, pPriv->swap_count);
 	pPriv->target_sbc = -1;
 
 	AttendClient(pPriv->blockedClient);
 	pPriv->blockedClient = NULL;
-    } else if (pPriv->target_sbc == -1) {
-	if (pPriv->blockedClient)
+    } else if (pPriv->target_sbc == -1 && !pPriv->blockedOnMsc) {
+	if (pPriv->blockedClient) {
 	    AttendClient(pPriv->blockedClient);
-	pPriv->blockedClient = NULL;
+	    pPriv->blockedClient = NULL;
+	}
     }
 }
 
@@ -534,21 +565,24 @@ DRI2SwapComplete(ClientPtr client, DrawablePtr pDraw, int frame,
 	return;
     }
 
-    if (pPriv->refCount == 0) {
-        xf86DrvMsg(pScreen->myNum, X_ERROR,
-		   "[DRI2] %s: bad drawable refcount\n", __func__);
-	DRI2FreeDrawable(pDraw);
-	return;
-    }
+    pPriv->swapsPending--;
+    pPriv->swap_count++;
 
     ust = ((CARD64)tv_sec * 1000000) + tv_usec;
     if (swap_complete)
 	swap_complete(client, swap_data, type, ust, frame, pPriv->swap_count);
 
-    pPriv->swapsPending--;
-    pPriv->swap_count++;
+    pPriv->last_swap_msc = frame;
+    pPriv->last_swap_ust = ust;
 
     DRI2WakeClient(client, pDraw, frame, tv_sec, tv_usec);
+
+    /*
+     * It's normal for the app to have exited with a swap outstanding, but
+     * don't free the drawable until they're all complete.
+     */
+    if (pPriv->swapsPending == 0 && pPriv->refCount == 0)
+	DRI2FreeDrawable(pDraw);
 }
 
 Bool
@@ -563,7 +597,7 @@ DRI2WaitSwap(ClientPtr client, DrawablePtr pDrawable)
 	pPriv->blockedClient == NULL) {
 	ResetCurrentRequest(client);
 	client->sequence--;
-	DRI2BlockClient(client, pDrawable);
+	__DRI2BlockClient(client, pPriv);
 	return TRUE;
     }
 
@@ -579,7 +613,6 @@ DRI2SwapBuffers(ClientPtr client, DrawablePtr pDraw, CARD64 target_msc,
     DRI2ScreenPtr   ds = DRI2GetScreen(pDraw->pScreen);
     DRI2DrawablePtr pPriv;
     DRI2BufferPtr   pDestBuffer = NULL, pSrcBuffer = NULL;
-    CARD64          ust;
     int             ret, i;
 
     pPriv = DRI2GetDrawable(pDraw);
@@ -601,8 +634,8 @@ DRI2SwapBuffers(ClientPtr client, DrawablePtr pDraw, CARD64 target_msc,
 	return BadDrawable;
     }
 
-    /* Old DDX, just blit */
-    if (!ds->ScheduleSwap) {
+    /* Old DDX or no swap interval, just blit */
+    if (!ds->ScheduleSwap || !pPriv->swap_interval) {
 	BoxRec box;
 	RegionRec region;
 
@@ -623,52 +656,52 @@ DRI2SwapBuffers(ClientPtr client, DrawablePtr pDraw, CARD64 target_msc,
     /*
      * In the simple glXSwapBuffers case, all params will be 0, and we just
      * need to schedule a swap for the last swap target + the swap interval.
-     * If the last swap target hasn't been set yet, call into the driver
-     * to get the current count.
      */
-    if (target_msc == 0 && divisor == 0 && remainder == 0 &&
-	pPriv->last_swap_target < 0) {
-	ret = (*ds->GetMSC)(pDraw, &ust, &target_msc);
-	if (!ret) {
-	    xf86DrvMsg(pScreen->myNum, X_ERROR,
-		       "[DRI2] %s: driver failed to return current MSC\n",
-		       __func__);
-	    return BadDrawable;
-	}
+    if (target_msc == 0 && divisor == 0 && remainder == 0) {
+	/*
+	 * Swap target for this swap is last swap target + swap interval since
+	 * we have to account for the current swap count, interval, and the
+	 * number of pending swaps.
+	 */
+	*swap_target = pPriv->last_swap_target + pPriv->swap_interval;
+    } else {
+	/* glXSwapBuffersMscOML could have a 0 target_msc, honor it */
+	*swap_target = target_msc;
     }
 
-    /* First swap needs to initialize last_swap_target */
-    if (pPriv->last_swap_target < 0)
-	pPriv->last_swap_target = target_msc;
-
-    /*
-     * Swap target for this swap is last swap target + swap interval since
-     * we have to account for the current swap count, interval, and the
-     * number of pending swaps.
-     */
-    *swap_target = pPriv->last_swap_target + pPriv->swap_interval;
-
+    pPriv->swapsPending++;
     ret = (*ds->ScheduleSwap)(client, pDraw, pDestBuffer, pSrcBuffer,
 			      swap_target, divisor, remainder, func, data);
     if (!ret) {
+	pPriv->swapsPending--; /* didn't schedule */
         xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[DRI2] %s: driver failed to schedule swap\n", __func__);
 	return BadDrawable;
     }
 
-    pPriv->swapsPending++;
     pPriv->last_swap_target = *swap_target;
 
+    /* According to spec, return expected swapbuffers count SBC after this swap
+     * will complete.
+     */
+    *swap_target = pPriv->swap_count + pPriv->swapsPending;
+
     return Success;
 }
 
 void
 DRI2SwapInterval(DrawablePtr pDrawable, int interval)
 {
+    ScreenPtr       pScreen = pDrawable->pScreen;
     DRI2DrawablePtr pPriv = DRI2GetDrawable(pDrawable);
 
-    /* fixme: check against arbitrary max? */
+    if (pPriv == NULL) {
+        xf86DrvMsg(pScreen->myNum, X_ERROR,
+		   "[DRI2] %s: bad drawable\n", __func__);
+	return;
+    }
 
+    /* fixme: check against arbitrary max? */
     pPriv->swap_interval = interval;
 }
 
@@ -717,7 +750,7 @@ DRI2WaitMSC(ClientPtr client, DrawablePtr pDraw, CARD64 target_msc,
     Bool ret;
 
     pPriv = DRI2GetDrawable(pDraw);
-    if (pPriv == NULL)
+    if (pPriv == NULL || pPriv->refCount == 0)
 	return BadDrawable;
 
     /* Old DDX just completes immediately */
@@ -741,14 +774,28 @@ DRI2WaitSBC(ClientPtr client, DrawablePtr pDraw, CARD64 target_sbc,
     DRI2DrawablePtr pPriv;
 
     pPriv = DRI2GetDrawable(pDraw);
-    if (pPriv == NULL)
+    if (pPriv == NULL || pPriv->refCount == 0)
 	return BadDrawable;
 
-    if (pPriv->swap_count >= target_sbc)
-	return Success;
+    /* target_sbc == 0 means to block until all pending swaps are
+     * finished. Recalculate target_sbc to get that behaviour.
+     */
+    if (target_sbc == 0)
+        target_sbc = pPriv->swap_count + pPriv->swapsPending;
+
+    /* If current swap count already >= target_sbc,
+     * return immediately with (ust, msc, sbc) triplet of
+     * most recent completed swap.
+     */
+    if (pPriv->swap_count >= target_sbc) {
+        *sbc = pPriv->swap_count;
+        *msc = pPriv->last_swap_msc;
+        *ust = pPriv->last_swap_ust;
+        return Success;
+    }
 
     pPriv->target_sbc = target_sbc;
-    DRI2BlockClient(client, pDraw);
+    __DRI2BlockClient(client, pPriv);
 
     return Success;
 }
@@ -776,14 +823,22 @@ DRI2DestroyDrawable(DrawablePtr pDraw)
 	xfree(pPriv->buffers);
     }
 
-    /* If the window is destroyed while we have a swap pending, don't
+    /* If the window is destroyed while we have a swap or wait pending, don't
      * actually free the priv yet.  We'll need it in the DRI2SwapComplete()
      * callback and we'll free it there once we're done. */
-    if (!pPriv->swapsPending)
+    if (!pPriv->swapsPending && !pPriv->blockedClient)
 	DRI2FreeDrawable(pDraw);
 }
 
 Bool
+DRI2HasSwapControl(ScreenPtr pScreen)
+{
+    DRI2ScreenPtr ds = DRI2GetScreen(pScreen);
+
+    return (ds->ScheduleSwap && ds->GetMSC);
+}
+
+Bool
 DRI2Connect(ScreenPtr pScreen, unsigned int driverType, int *fd,
 	    const char **driverName, const char **deviceName)
 {
@@ -820,6 +875,7 @@ DRI2ScreenInit(ScreenPtr pScreen, DRI2InfoPtr info)
 	"VDPAU", /* DRI2DriverVDPAU */
     };
     unsigned int i;
+    CARD8 cur_minor;
 
     if (info->version < 3)
 	return FALSE;
@@ -836,6 +892,7 @@ DRI2ScreenInit(ScreenPtr pScreen, DRI2InfoPtr info)
 
     ds->fd	       = info->fd;
     ds->deviceName     = info->deviceName;
+    dri2_major         = 1;
 
     ds->CreateBuffer   = info->CreateBuffer;
     ds->DestroyBuffer  = info->DestroyBuffer;
@@ -845,8 +902,15 @@ DRI2ScreenInit(ScreenPtr pScreen, DRI2InfoPtr info)
 	ds->ScheduleSwap = info->ScheduleSwap;
 	ds->ScheduleWaitMSC = info->ScheduleWaitMSC;
 	ds->GetMSC = info->GetMSC;
+	cur_minor = 2;
+    } else {
+	cur_minor = 1;
     }
 
+    /* Initialize minor if needed and set to minimum provied by DDX */
+    if (!dri2_minor || dri2_minor > cur_minor)
+	dri2_minor = cur_minor;
+
     if (info->version == 3 || info->numDrivers == 0) {
 	/* Driver too old: use the old-style driverName field */
 	ds->numDrivers = 1;
diff --git a/hw/xfree86/dri2/dri2.h b/hw/xfree86/dri2/dri2.h
index 1c8626b..ce8a5df 100644
--- a/hw/xfree86/dri2/dri2.h
+++ b/hw/xfree86/dri2/dri2.h
@@ -46,6 +46,9 @@ typedef struct {
     void *driverPrivate;
 } DRI2BufferRec, *DRI2BufferPtr;
 
+extern CARD8 dri2_major; /* version of DRI2 supported by DDX */
+extern CARD8 dri2_minor;
+
 typedef DRI2BufferRec DRI2Buffer2Rec, *DRI2Buffer2Ptr;
 typedef void (*DRI2SwapEventPtr)(ClientPtr client, void *data, int type,
 				 CARD64 ust, CARD64 msc, CARD64 sbc);
@@ -185,6 +188,8 @@ extern _X_EXPORT Bool DRI2ScreenInit(ScreenPtr	pScreen,
 
 extern _X_EXPORT void DRI2CloseScreen(ScreenPtr pScreen);
 
+extern _X_EXPORT Bool DRI2HasSwapControl(ScreenPtr pScreen);
+
 extern _X_EXPORT Bool DRI2Connect(ScreenPtr pScreen,
 		 unsigned int driverType,
 		 int *fd,
@@ -254,6 +259,7 @@ extern _X_EXPORT Bool DRI2CanFlip(DrawablePtr pDraw);
 
 extern _X_EXPORT Bool DRI2CanExchange(DrawablePtr pDraw);
 
+/* Note: use *only* for MSC related waits */
 extern _X_EXPORT void DRI2BlockClient(ClientPtr client, DrawablePtr pDraw);
 
 extern _X_EXPORT void DRI2SwapComplete(ClientPtr client, DrawablePtr pDraw,
diff --git a/hw/xfree86/dri2/dri2ext.c b/hw/xfree86/dri2/dri2ext.c
index bd92fd3..094d54d 100644
--- a/hw/xfree86/dri2/dri2ext.c
+++ b/hw/xfree86/dri2/dri2ext.c
@@ -80,8 +80,8 @@ ProcDRI2QueryVersion(ClientPtr client)
     rep.type = X_Reply;
     rep.length = 0;
     rep.sequenceNumber = client->sequence;
-    rep.majorVersion = SERVER_DRI2_MAJOR_VERSION;
-    rep.minorVersion = SERVER_DRI2_MINOR_VERSION;
+    rep.majorVersion = dri2_major;
+    rep.minorVersion = dri2_minor;
 
     if (client->swapped) {
     	swaps(&rep.sequenceNumber, n);
@@ -384,6 +384,13 @@ ProcDRI2SwapBuffers(ClientPtr client)
 		       DixReadAccess | DixWriteAccess, &pDrawable, &status))
 	return status;
 
+    /*
+     * Ensures an out of control client can't exhaust our swap queue, and
+     * also orders swaps.
+     */
+    if (DRI2ThrottleClient(client, pDrawable))
+	return client->noClientException;
+
     target_msc = vals_to_card64(stuff->target_msc_lo, stuff->target_msc_hi);
     divisor = vals_to_card64(stuff->divisor_lo, stuff->divisor_hi);
     remainder = vals_to_card64(stuff->remainder_lo, stuff->remainder_hi);
diff --git a/hw/xfree86/modes/xf86Cursors.c b/hw/xfree86/modes/xf86Cursors.c
index e2e174e..4162999 100644
--- a/hw/xfree86/modes/xf86Cursors.c
+++ b/hw/xfree86/modes/xf86Cursors.c
@@ -611,7 +611,7 @@ xf86_reload_cursors (ScreenPtr screen)
     cursor_screen_priv = dixLookupPrivate(&screen->devPrivates,
 					  xf86CursorScreenKey);
     /* return if HW cursor is inactive, to avoid displaying two cursors */
-    if (!cursor_screen_priv->isUp)
+    if (!cursor_screen_priv || !cursor_screen_priv->isUp)
 	return;
 
     scrn = xf86Screens[screen->myNum];
diff --git a/hw/xfree86/os-support/solaris/sun_init.c b/hw/xfree86/os-support/solaris/sun_init.c
index 5846866..edcc60b 100644
--- a/hw/xfree86/os-support/solaris/sun_init.c
+++ b/hw/xfree86/os-support/solaris/sun_init.c
@@ -33,8 +33,21 @@
 # include <sys/kd.h>
 #endif
 
+/*
+ * Applications see VT number as consecutive integers starting from 1.
+ * VT number			VT device
+ * -------------------------------------------------------
+ *     1             :          /dev/vt/0 (Alt + Ctrl + F1)
+ *     2             :          /dev/vt/2 (Alt + Ctrl + F2)
+ *     3             :          /dev/vt/3 (Alt + Ctrl + F3)
+ *  ... ...
+ */
+#define	CONSOLE_VTNO	1
+#define	SOL_CONSOLE_DEV	"/dev/console"
+
 static Bool KeepTty = FALSE;
 static Bool Protect0 = FALSE;
+static Bool UseConsole = FALSE;
 #ifdef HAS_USL_VTS
 static int VTnum = -1;
 static int xf86StartVT = -1;
@@ -112,8 +125,30 @@ xf86OpenConsole(void)
 		vtEnabled = 0;
 	    }
 	}
+#endif /*  HAS_USL_VTS */
 
+	if (UseConsole)
+	{
+	    strlcpy(consoleDev, SOL_CONSOLE_DEV, sizeof(consoleDev));
+
+#ifdef HAS_USL_VTS
+	    xf86Info.vtno = CONSOLE_VTNO;
 
+	    if (vtEnabled == 0)
+	    {
+		xf86StartVT = 0;
+	    }
+	    else
+	    {
+		if (ioctl(fd, VT_GETSTATE, &vtinfo) < 0)
+		    FatalError("xf86OpenConsole: Cannot determine current VT\n");
+		xf86StartVT = vtinfo.v_active;
+	    }
+#endif /*  HAS_USL_VTS */
+	    goto OPENCONSOLE;
+	}
+
+#ifdef HAS_USL_VTS
 	if (vtEnabled == 0)
 	{
 	    /* VT not enabled - kernel too old or Sparc platforms
@@ -123,32 +158,31 @@ xf86OpenConsole(void)
 	    xf86StartVT = 0;
 	    xf86Info.vtno = 0;
 	    strlcpy(consoleDev, xf86SolarisFbDev, sizeof(consoleDev));
+	    goto OPENCONSOLE;
 	}
-	else
-	{
-	    if (ioctl(fd, VT_GETSTATE, &vtinfo) < 0)
-		FatalError("xf86OpenConsole: Cannot determine current VT\n");
 
-	    xf86StartVT = vtinfo.v_active;
+	if (ioctl(fd, VT_GETSTATE, &vtinfo) < 0)
+	    FatalError("xf86OpenConsole: Cannot determine current VT\n");
 
-	    if (VTnum != -1)
-	    {
-		xf86Info.vtno = VTnum;
-		from = X_CMDLINE;
-	    }
-	    else
+	xf86StartVT = vtinfo.v_active;
+
+	if (VTnum != -1)
+	{
+	    xf86Info.vtno = VTnum;
+	    from = X_CMDLINE;
+	}
+	else
+	{
+	    if ((ioctl(fd, VT_OPENQRY, &xf86Info.vtno) < 0) ||
+		(xf86Info.vtno == -1))
 	    {
-		if ((ioctl(fd, VT_OPENQRY, &xf86Info.vtno) < 0) ||
-		    (xf86Info.vtno == -1))
-		{
-		    FatalError("xf86OpenConsole: Cannot find a free VT\n");
-		}
+		FatalError("xf86OpenConsole: Cannot find a free VT\n");
 	    }
-
-	    xf86Msg(from, "using VT number %d\n\n", xf86Info.vtno);
-	    snprintf(consoleDev, PATH_MAX, "/dev/vt/%d", xf86Info.vtno);
 	}
 
+	xf86Msg(from, "using VT number %d\n\n", xf86Info.vtno);
+	snprintf(consoleDev, PATH_MAX, "/dev/vt/%d", xf86Info.vtno);
+
 	if (fd != -1)
 	{
 	    close(fd);
@@ -156,6 +190,7 @@ xf86OpenConsole(void)
 
 #endif /* HAS_USL_VTS */
 
+OPENCONSOLE:
 	if (!KeepTty)
 	    setpgrp();
 
@@ -163,11 +198,10 @@ xf86OpenConsole(void)
 	    FatalError("xf86OpenConsole: Cannot open %s (%s)\n",
 		       consoleDev, strerror(errno));
 
-#ifdef HAS_USL_VTS
-
-	/* Change ownership of the vt */
+	/* Change ownership of the vt or console */
 	chown(consoleDev, getuid(), getgid());
 
+#ifdef HAS_USL_VTS
 	if (vtEnabled)
 	{
 	    /*
@@ -179,6 +213,13 @@ xf86OpenConsole(void)
 	    if (ioctl(xf86Info.consoleFd, VT_WAITACTIVE, xf86Info.vtno) != 0)
 		xf86Msg(X_WARNING, "xf86OpenConsole: VT_WAITACTIVE failed\n");
 
+#ifdef VT_SET_CONSUSER /* added in snv_139 */
+	    if (strcmp(display, "0") == 0)
+		if (ioctl(xf86Info.consoleFd, VT_SET_CONSUSER) != 0)
+		    xf86Msg(X_WARNING,
+			"xf86OpenConsole: VT_SET_CONSUSER failed\n");
+#endif
+
 	    if (ioctl(xf86Info.consoleFd, VT_GETMODE, &VT) < 0)
 		FatalError("xf86OpenConsole: VT_GETMODE failed\n");
 
@@ -220,6 +261,13 @@ xf86OpenConsole(void)
 	    if (ioctl(xf86Info.consoleFd, VT_WAITACTIVE, xf86Info.vtno) != 0)
 		xf86Msg(X_WARNING, "xf86OpenConsole: VT_WAITACTIVE failed\n");
 
+#ifdef VT_SET_CONSUSER /* added in snv_139 */
+	    if (strcmp(display, "0") == 0)
+		if (ioctl(xf86Info.consoleFd, VT_SET_CONSUSER) != 0)
+		    xf86Msg(X_WARNING,
+			"xf86OpenConsole: VT_SET_CONSUSER failed\n");
+#endif
+
 	    /*
 	     * If the server doesn't have the VT when the reset occurs,
 	     * this is to make sure we don't continue until the activate
@@ -330,6 +378,15 @@ xf86ProcessArgument(int argc, char **argv, int i)
 	return 1;
     }
 
+    /*
+     * Use /dev/console as the console device.
+     */
+    if (!strcmp(argv[i], "-C"))
+    {
+	UseConsole = TRUE;
+	return 1;
+    }
+
 #ifdef HAS_USL_VTS
 
     if ((argv[i][0] == 'v') && (argv[i][1] == 't'))
@@ -364,4 +421,5 @@ void xf86UseMsg()
     ErrorF("-dev <fb>              Framebuffer device\n");
     ErrorF("-keeptty               Don't detach controlling tty\n");
     ErrorF("                       (for debugging only)\n");
+    ErrorF("-C                     Use /dev/console as the console device\n");
 }
diff --git a/hw/xfree86/ramdac/xf86Cursor.c b/hw/xfree86/ramdac/xf86Cursor.c
index f5f0873..346e994 100644
--- a/hw/xfree86/ramdac/xf86Cursor.c
+++ b/hw/xfree86/ramdac/xf86Cursor.c
@@ -312,6 +312,8 @@ xf86CursorSetCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCurs,
             xf86SetCursor(pScreen, NullCursor, x, y);
             ScreenPriv->isUp = FALSE;
         }
+	if (ScreenPriv->CurrentCursor)
+	    FreeCursor(ScreenPriv->CurrentCursor, None);
         ScreenPriv->CurrentCursor = NullCursor;
         return;
     }
diff --git a/hw/xquartz/X11Application.m b/hw/xquartz/X11Application.m
index c9a0d66..805ed99 100644
--- a/hw/xquartz/X11Application.m
+++ b/hw/xquartz/X11Application.m
@@ -1030,20 +1030,32 @@ static inline int ensure_flag(int flags, int device_independent, int device_depe
     if(isMouseOrTabletEvent) {
         static NSPoint lastpt;
         NSWindow *window = [e window];
-        NSRect screen = [[[NSScreen screens] objectAtIndex:0] frame];;
-
+        NSRect screen = [[[NSScreen screens] objectAtIndex:0] frame];
+	    BOOL hasUntrustedPointerDelta;
+        
+        // NSEvents for tablets are not consistent wrt deltaXY between events, so we cannot rely on that
+        // Thus tablets will be subject to the warp-pointer bug worked around by the delta, but tablets
+        // are not normally used in cases where that bug would present itself, so this is a fair tradeoff
+        // <rdar://problem/7111003> deltaX and deltaY are incorrect for NSMouseMoved, NSTabletPointEventSubtype
+        // http://xquartz.macosforge.org/trac/ticket/288
+        hasUntrustedPointerDelta = isTabletEvent;
+        
+        // The deltaXY for middle click events also appear erroneous after fast user switching
+        // <rdar://problem/7979468> deltaX and deltaY are incorrect for NSOtherMouseDown and NSOtherMouseUp after FUS
+        // http://xquartz.macosforge.org/trac/ticket/389
+        hasUntrustedPointerDelta = hasUntrustedPointerDelta || [e type] == NSOtherMouseDown || [e type] == NSOtherMouseUp;
+
+        // The deltaXY for scroll events correspond to the scroll delta, not the pointer delta
+        // <rdar://problem/7989690> deltaXY for wheel events are being sent as mouse movement
+        hasUntrustedPointerDelta = hasUntrustedPointerDelta || [e type] == NSScrollWheel;
+        
         if (window != nil)	{
             NSRect frame = [window frame];
             location = [e locationInWindow];
             location.x += frame.origin.x;
             location.y += frame.origin.y;
             lastpt = location;
-        } else if(isTabletEvent) {
-            // NSEvents for tablets are not consistent wrt deltaXY between events, so we cannot rely on that
-            // Thus tablets will be subject to the warp-pointer bug worked around by the delta, but tablets
-            // are not normally used in cases where that bug would present itself, so this is a fair tradeoff
-            // <rdar://problem/7111003> deltaX and deltaY are incorrect for NSMouseMoved, NSTabletPointEventSubtype
-            // http://xquartz.macosforge.org/trac/ticket/288
+        } else if(hasUntrustedPointerDelta) {
             location = [e locationInWindow];
             lastpt = location;
         } else {
diff --git a/hw/xquartz/mach-startup/bundle-main.c b/hw/xquartz/mach-startup/bundle-main.c
index 42aa757..63a185f 100644
--- a/hw/xquartz/mach-startup/bundle-main.c
+++ b/hw/xquartz/mach-startup/bundle-main.c
@@ -75,7 +75,12 @@ extern int noPanoramiXExtension;
 
 static char __crashreporter_info_buff__[4096] = {0};
 static const char *__crashreporter_info__ = &__crashreporter_info_buff__[0];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
+// This is actually a toolchain requirement, but I'm not sure the correct check,
+// but it should be fine to just only include it for Leopard and later.  This line
+// just tells the linker to never strip this symbol (such as for space optimization)
 asm (".desc ___crashreporter_info__, 0x10");
+#endif
 
 static const char *__crashreporter_info__base = "X.Org X Server " XSERVER_VERSION " Build Date: " BUILD_DATE;
 
diff --git a/include/eventstr.h b/include/eventstr.h
index 79685c1..433227e 100644
--- a/include/eventstr.h
+++ b/include/eventstr.h
@@ -91,9 +91,9 @@ struct _DeviceEvent
         uint32_t button;  /**< Button number */
         uint32_t key;     /**< Key code */
     } detail;
-    uint16_t root_x;      /**< Pos relative to root window in integral data */
+    int16_t root_x;       /**< Pos relative to root window in integral data */
     float root_x_frac;    /**< Pos relative to root window in frac part */
-    uint16_t root_y;      /**< Pos relative to root window in integral part */
+    int16_t root_y;       /**< Pos relative to root window in integral part */
     float root_y_frac;    /**< Pos relative to root window in frac part */
     uint8_t    buttons[(MAX_BUTTONS + 7)/8]; /**< Button mask */
     struct {
diff --git a/include/protocol-versions.h b/include/protocol-versions.h
index c74b7fa..97ef5da 100644
--- a/include/protocol-versions.h
+++ b/include/protocol-versions.h
@@ -51,10 +51,6 @@
 #define SERVER_DMX_MINOR_VERSION		2
 #define SERVER_DMX_PATCH_VERSION		20040604
 
-/* DRI2 */
-#define SERVER_DRI2_MAJOR_VERSION		1
-#define SERVER_DRI2_MINOR_VERSION		2
-
 /* Generic event extension */
 #define SERVER_GE_MAJOR_VERSION                 1
 #define SERVER_GE_MINOR_VERSION                 0
diff --git a/mi/miarc.c b/mi/miarc.c
index 5fd1a67..ddcbff7 100644
--- a/mi/miarc.c
+++ b/mi/miarc.c
@@ -1524,7 +1524,7 @@ miRoundCap(
 
 # define Dsin(d)	((d) == 0.0 ? 0.0 : ((d) == 90.0 ? 1.0 : sin(d*M_PI/180.0)))
 # define Dcos(d)	((d) == 0.0 ? 1.0 : ((d) == 90.0 ? 0.0 : cos(d*M_PI/180.0)))
-# define mod(a,b)	((a) >= 0 ? (a) % (b) : (b) - (-a) % (b))
+# define mod(a,b)	((a) >= 0 ? (a) % (b) : (b) - (-(a)) % (b))
 
 static double
 miDcos (double a)
diff --git a/mi/midispcur.c b/mi/midispcur.c
index 9041630..54a6787 100644
--- a/mi/midispcur.c
+++ b/mi/midispcur.c
@@ -780,7 +780,7 @@ miDCDeviceInitialize(DeviceIntPtr pDev, ScreenPtr pScreen)
     {
         pScreen = screenInfo.screens[i];
 
-        pBuffer = xalloc(sizeof(miDCBufferRec));
+        pBuffer = xcalloc(1, sizeof(miDCBufferRec));
         if (!pBuffer)
             goto failure;
 
diff --git a/mi/mipolypnt.c b/mi/mipolypnt.c
index 5d6243a..12771ee 100644
--- a/mi/mipolypnt.c
+++ b/mi/mipolypnt.c
@@ -73,6 +73,9 @@ miPolyPoint(
     int			i;
     xPoint 		*ppt;
 
+    if(!(pwidthInit = xalloc(npt * sizeof(int))))
+	return;
+
     /* make pointlist origin relative */
     if (mode == CoordModePrevious)
     {
@@ -107,8 +110,6 @@ miPolyPoint(
 	DoChangeGC(pGC, GCFillStyle, &fsNew, 0);
 	ValidateGC(pDrawable, pGC);
     }
-    if(!(pwidthInit = xalloc(npt * sizeof(int))))
-	return;
     pwidth = pwidthInit;
     for(i = 0; i < npt; i++)
 	*pwidth++ = 1;
diff --git a/os/access.c b/os/access.c
index 74c340a..3572da0 100644
--- a/os/access.c
+++ b/os/access.c
@@ -765,7 +765,8 @@ DefineSelf (int fd)
 	    continue;
 #endif /* DNETCONN */
 	len = sizeof(*(ifr->ifa_addr));
-	family = ConvertAddr(ifr->ifa_addr, &len, (pointer *)&addr);
+	family = ConvertAddr((struct sockaddr *) ifr->ifa_addr, &len,
+			     (pointer *)&addr);
 	if (family == -1 || family == FamilyLocal) 
 	    continue;
 #if defined(IPv6) && defined(AF_INET6)
@@ -789,7 +790,6 @@ DefineSelf (int fd)
 	}
 #ifdef XDMCP
 	{
-	    struct sockaddr broad_addr;
 	    /*
 	     * If this isn't an Internet Address, don't register it.
 	     */
@@ -835,11 +835,10 @@ DefineSelf (int fd)
 	    if ((ifr->ifa_flags & IFF_BROADCAST) &&
 		(ifr->ifa_flags & IFF_UP) &&
                 ifr->ifa_broadaddr)
-		broad_addr = *ifr->ifa_broadaddr;
+		XdmcpRegisterBroadcastAddress(
+		    (struct sockaddr_in *) ifr->ifa_broadaddr);
 	    else
 		continue;
-	    XdmcpRegisterBroadcastAddress((struct sockaddr_in *)
-					  &broad_addr);
 	}
 #endif /* XDMCP */
 		
diff --git a/os/log.c b/os/log.c
index 3773315..185bf61 100644
--- a/os/log.c
+++ b/os/log.c
@@ -118,10 +118,17 @@ static int bufferSize = 0, bufferUnused = 0, bufferPos = 0;
 static Bool needBuffer = TRUE;
 
 #ifdef __APPLE__
+#include <AvailabilityMacros.h>
+
 static char __crashreporter_info_buff__[4096] = {0};
 static const char *__crashreporter_info__ = &__crashreporter_info_buff__[0];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
+// This is actually a toolchain requirement, but I'm not sure the correct check,        
+// but it should be fine to just only include it for Leopard and later.  This line
+// just tells the linker to never strip this symbol (such as for space optimization)
 asm (".desc ___crashreporter_info__, 0x10");
 #endif
+#endif
 
 /* Prefix strings for log messages. */
 #ifndef X_UNKNOWN_STRING
diff --git a/render/render.c b/render/render.c
index 2d9e47a..afe4c92 100644
--- a/render/render.c
+++ b/render/render.c
@@ -1159,6 +1159,12 @@ ProcRenderAddGlyphs (ClientPtr client)
 						   width, height, depth,
 						   CREATE_PIXMAP_USAGE_GLYPH_PICTURE);
 
+		if (!pDstPix)
+		{
+		    err = BadAlloc;
+		    goto bail;
+		}
+
 		GlyphPicture (glyph)[screen] = pDst =
 			CreatePicture (0, &pDstPix->drawable,
 				       glyphSet->format,
@@ -1168,6 +1174,7 @@ ProcRenderAddGlyphs (ClientPtr client)
 		/* The picture takes a reference to the pixmap, so we
 		   drop ours. */
 		(pScreen->DestroyPixmap) (pDstPix);
+		pDstPix = NULL;
 
 		if (! pDst)
 		{
diff --git a/test/xi2/protocol-common.c b/test/xi2/protocol-common.c
index 2dff1ad..8638fd9 100644
--- a/test/xi2/protocol-common.c
+++ b/test/xi2/protocol-common.c
@@ -153,6 +153,7 @@ void init_simple(void)
     screen.SetCursorPosition = set_cursor_pos;
 
     dixResetPrivates();
+    InitAtoms();
     XInputExtensionInit();
     init_window(&root, NULL, ROOT_WINDOW_ID);
     init_window(&window, &root, CLIENT_WINDOW_ID);
diff --git a/xfixes/cursor.c b/xfixes/cursor.c
index 1471a58..2aba0ce 100644
--- a/xfixes/cursor.c
+++ b/xfixes/cursor.c
@@ -1054,11 +1054,15 @@ createInvisibleCursor (void)
     cm.xhot = 0;
     cm.yhot = 0;
 
-    AllocARGBCursor(psrcbits, pmaskbits,
-		NULL, &cm,
-		0, 0, 0,
-		0, 0, 0,
-		&pCursor, serverClient, (XID)0);
+    if (AllocARGBCursor(psrcbits, pmaskbits,
+			NULL, &cm,
+			0, 0, 0,
+			0, 0, 0,
+			&pCursor, serverClient, (XID)0) != Success)
+	return NullCursor;
+
+    if (!AddResource(FakeClientID(0), RT_CURSOR, (pointer) pCursor))
+	return NullCursor;
 
     return pCursor;
 }
@@ -1091,12 +1095,9 @@ XFixesCursorInit (void)
     CursorWindowType = CreateNewResourceType(CursorFreeWindow,
 					     "XFixesCursorWindow");
 
-    if (pInvisibleCursor == NULL) {
-	pInvisibleCursor = createInvisibleCursor();
-	if (pInvisibleCursor == NULL) {
-	    return BadAlloc;
-	}
-    }
+    pInvisibleCursor = createInvisibleCursor();
+    if (pInvisibleCursor == NULL)
+	return BadAlloc;
 
     return CursorClientType && CursorHideCountType && CursorWindowType;
 }
